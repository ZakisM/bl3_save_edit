// This file is generated by rust-protobuf 2.25.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `oak_shared.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_2;

#[derive(PartialEq,Clone,Default)]
pub struct Vec3 {
    // message fields
    pub x: f32,
    pub y: f32,
    pub z: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Vec3 {
    fn default() -> &'a Vec3 {
        <Vec3 as ::protobuf::Message>::default_instance()
    }
}

impl Vec3 {
    pub fn new() -> Vec3 {
        ::std::default::Default::default()
    }

    // float x = 1;


    pub fn get_x(&self) -> f32 {
        self.x
    }
    pub fn clear_x(&mut self) {
        self.x = 0.;
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = v;
    }

    // float y = 2;


    pub fn get_y(&self) -> f32 {
        self.y
    }
    pub fn clear_y(&mut self) {
        self.y = 0.;
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = v;
    }

    // float z = 3;


    pub fn get_z(&self) -> f32 {
        self.z
    }
    pub fn clear_z(&mut self) {
        self.z = 0.;
    }

    // Param is passed by value, moved
    pub fn set_z(&mut self, v: f32) {
        self.z = v;
    }
}

impl ::protobuf::Message for Vec3 {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.x = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.y = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.z = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.x != 0. {
            my_size += 5;
        }
        if self.y != 0. {
            my_size += 5;
        }
        if self.z != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.x != 0. {
            os.write_float(1, self.x)?;
        }
        if self.y != 0. {
            os.write_float(2, self.y)?;
        }
        if self.z != 0. {
            os.write_float(3, self.z)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Vec3 {
        Vec3::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "x",
                |m: &Vec3| { &m.x },
                |m: &mut Vec3| { &mut m.x },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "y",
                |m: &Vec3| { &m.y },
                |m: &mut Vec3| { &mut m.y },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "z",
                |m: &Vec3| { &m.z },
                |m: &mut Vec3| { &mut m.z },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Vec3>(
                "Vec3",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Vec3 {
        static instance: ::protobuf::rt::LazyV2<Vec3> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Vec3::new)
    }
}

impl ::protobuf::Clear for Vec3 {
    fn clear(&mut self) {
        self.x = 0.;
        self.y = 0.;
        self.z = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Vec3 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Vec3 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GameStatSaveGameData {
    // message fields
    pub stat_value: i32,
    pub stat_path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GameStatSaveGameData {
    fn default() -> &'a GameStatSaveGameData {
        <GameStatSaveGameData as ::protobuf::Message>::default_instance()
    }
}

impl GameStatSaveGameData {
    pub fn new() -> GameStatSaveGameData {
        ::std::default::Default::default()
    }

    // int32 stat_value = 1;


    pub fn get_stat_value(&self) -> i32 {
        self.stat_value
    }
    pub fn clear_stat_value(&mut self) {
        self.stat_value = 0;
    }

    // Param is passed by value, moved
    pub fn set_stat_value(&mut self, v: i32) {
        self.stat_value = v;
    }

    // string stat_path = 2;


    pub fn get_stat_path(&self) -> &str {
        &self.stat_path
    }
    pub fn clear_stat_path(&mut self) {
        self.stat_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_stat_path(&mut self, v: ::std::string::String) {
        self.stat_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stat_path(&mut self) -> &mut ::std::string::String {
        &mut self.stat_path
    }

    // Take field
    pub fn take_stat_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.stat_path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GameStatSaveGameData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.stat_value = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.stat_path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.stat_value != 0 {
            my_size += ::protobuf::rt::value_size(1, self.stat_value, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.stat_path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.stat_path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.stat_value != 0 {
            os.write_int32(1, self.stat_value)?;
        }
        if !self.stat_path.is_empty() {
            os.write_string(2, &self.stat_path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GameStatSaveGameData {
        GameStatSaveGameData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "stat_value",
                |m: &GameStatSaveGameData| { &m.stat_value },
                |m: &mut GameStatSaveGameData| { &mut m.stat_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "stat_path",
                |m: &GameStatSaveGameData| { &m.stat_path },
                |m: &mut GameStatSaveGameData| { &mut m.stat_path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GameStatSaveGameData>(
                "GameStatSaveGameData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GameStatSaveGameData {
        static instance: ::protobuf::rt::LazyV2<GameStatSaveGameData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GameStatSaveGameData::new)
    }
}

impl ::protobuf::Clear for GameStatSaveGameData {
    fn clear(&mut self) {
        self.stat_value = 0;
        self.stat_path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GameStatSaveGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GameStatSaveGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InventoryCategorySaveData {
    // message fields
    pub base_category_definition_hash: u32,
    pub quantity: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InventoryCategorySaveData {
    fn default() -> &'a InventoryCategorySaveData {
        <InventoryCategorySaveData as ::protobuf::Message>::default_instance()
    }
}

impl InventoryCategorySaveData {
    pub fn new() -> InventoryCategorySaveData {
        ::std::default::Default::default()
    }

    // uint32 base_category_definition_hash = 1;


    pub fn get_base_category_definition_hash(&self) -> u32 {
        self.base_category_definition_hash
    }
    pub fn clear_base_category_definition_hash(&mut self) {
        self.base_category_definition_hash = 0;
    }

    // Param is passed by value, moved
    pub fn set_base_category_definition_hash(&mut self, v: u32) {
        self.base_category_definition_hash = v;
    }

    // int32 quantity = 2;


    pub fn get_quantity(&self) -> i32 {
        self.quantity
    }
    pub fn clear_quantity(&mut self) {
        self.quantity = 0;
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: i32) {
        self.quantity = v;
    }
}

impl ::protobuf::Message for InventoryCategorySaveData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.base_category_definition_hash = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.quantity = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.base_category_definition_hash != 0 {
            my_size += ::protobuf::rt::value_size(1, self.base_category_definition_hash, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.quantity != 0 {
            my_size += ::protobuf::rt::value_size(2, self.quantity, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.base_category_definition_hash != 0 {
            os.write_uint32(1, self.base_category_definition_hash)?;
        }
        if self.quantity != 0 {
            os.write_int32(2, self.quantity)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InventoryCategorySaveData {
        InventoryCategorySaveData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "base_category_definition_hash",
                |m: &InventoryCategorySaveData| { &m.base_category_definition_hash },
                |m: &mut InventoryCategorySaveData| { &mut m.base_category_definition_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "quantity",
                |m: &InventoryCategorySaveData| { &m.quantity },
                |m: &mut InventoryCategorySaveData| { &mut m.quantity },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InventoryCategorySaveData>(
                "InventoryCategorySaveData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InventoryCategorySaveData {
        static instance: ::protobuf::rt::LazyV2<InventoryCategorySaveData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InventoryCategorySaveData::new)
    }
}

impl ::protobuf::Clear for InventoryCategorySaveData {
    fn clear(&mut self) {
        self.base_category_definition_hash = 0;
        self.quantity = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InventoryCategorySaveData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InventoryCategorySaveData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OakSDUSaveGameData {
    // message fields
    pub sdu_level: i32,
    pub sdu_data_path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OakSDUSaveGameData {
    fn default() -> &'a OakSDUSaveGameData {
        <OakSDUSaveGameData as ::protobuf::Message>::default_instance()
    }
}

impl OakSDUSaveGameData {
    pub fn new() -> OakSDUSaveGameData {
        ::std::default::Default::default()
    }

    // int32 sdu_level = 1;


    pub fn get_sdu_level(&self) -> i32 {
        self.sdu_level
    }
    pub fn clear_sdu_level(&mut self) {
        self.sdu_level = 0;
    }

    // Param is passed by value, moved
    pub fn set_sdu_level(&mut self, v: i32) {
        self.sdu_level = v;
    }

    // string sdu_data_path = 2;


    pub fn get_sdu_data_path(&self) -> &str {
        &self.sdu_data_path
    }
    pub fn clear_sdu_data_path(&mut self) {
        self.sdu_data_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_sdu_data_path(&mut self, v: ::std::string::String) {
        self.sdu_data_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sdu_data_path(&mut self) -> &mut ::std::string::String {
        &mut self.sdu_data_path
    }

    // Take field
    pub fn take_sdu_data_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sdu_data_path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for OakSDUSaveGameData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.sdu_level = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sdu_data_path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.sdu_level != 0 {
            my_size += ::protobuf::rt::value_size(1, self.sdu_level, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.sdu_data_path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.sdu_data_path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.sdu_level != 0 {
            os.write_int32(1, self.sdu_level)?;
        }
        if !self.sdu_data_path.is_empty() {
            os.write_string(2, &self.sdu_data_path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OakSDUSaveGameData {
        OakSDUSaveGameData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "sdu_level",
                |m: &OakSDUSaveGameData| { &m.sdu_level },
                |m: &mut OakSDUSaveGameData| { &mut m.sdu_level },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sdu_data_path",
                |m: &OakSDUSaveGameData| { &m.sdu_data_path },
                |m: &mut OakSDUSaveGameData| { &mut m.sdu_data_path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OakSDUSaveGameData>(
                "OakSDUSaveGameData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OakSDUSaveGameData {
        static instance: ::protobuf::rt::LazyV2<OakSDUSaveGameData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OakSDUSaveGameData::new)
    }
}

impl ::protobuf::Clear for OakSDUSaveGameData {
    fn clear(&mut self) {
        self.sdu_level = 0;
        self.sdu_data_path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OakSDUSaveGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OakSDUSaveGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RegisteredDownloadableEntitlement {
    // message fields
    pub id: i32,
    pub consumed: u32,
    pub registered: bool,
    pub seen: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RegisteredDownloadableEntitlement {
    fn default() -> &'a RegisteredDownloadableEntitlement {
        <RegisteredDownloadableEntitlement as ::protobuf::Message>::default_instance()
    }
}

impl RegisteredDownloadableEntitlement {
    pub fn new() -> RegisteredDownloadableEntitlement {
        ::std::default::Default::default()
    }

    // int32 id = 1;


    pub fn get_id(&self) -> i32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = v;
    }

    // uint32 consumed = 2;


    pub fn get_consumed(&self) -> u32 {
        self.consumed
    }
    pub fn clear_consumed(&mut self) {
        self.consumed = 0;
    }

    // Param is passed by value, moved
    pub fn set_consumed(&mut self, v: u32) {
        self.consumed = v;
    }

    // bool registered = 3;


    pub fn get_registered(&self) -> bool {
        self.registered
    }
    pub fn clear_registered(&mut self) {
        self.registered = false;
    }

    // Param is passed by value, moved
    pub fn set_registered(&mut self, v: bool) {
        self.registered = v;
    }

    // bool seen = 4;


    pub fn get_seen(&self) -> bool {
        self.seen
    }
    pub fn clear_seen(&mut self) {
        self.seen = false;
    }

    // Param is passed by value, moved
    pub fn set_seen(&mut self, v: bool) {
        self.seen = v;
    }
}

impl ::protobuf::Message for RegisteredDownloadableEntitlement {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.consumed = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.registered = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.seen = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.consumed != 0 {
            my_size += ::protobuf::rt::value_size(2, self.consumed, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.registered != false {
            my_size += 2;
        }
        if self.seen != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if self.consumed != 0 {
            os.write_uint32(2, self.consumed)?;
        }
        if self.registered != false {
            os.write_bool(3, self.registered)?;
        }
        if self.seen != false {
            os.write_bool(4, self.seen)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RegisteredDownloadableEntitlement {
        RegisteredDownloadableEntitlement::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "id",
                |m: &RegisteredDownloadableEntitlement| { &m.id },
                |m: &mut RegisteredDownloadableEntitlement| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "consumed",
                |m: &RegisteredDownloadableEntitlement| { &m.consumed },
                |m: &mut RegisteredDownloadableEntitlement| { &mut m.consumed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "registered",
                |m: &RegisteredDownloadableEntitlement| { &m.registered },
                |m: &mut RegisteredDownloadableEntitlement| { &mut m.registered },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "seen",
                |m: &RegisteredDownloadableEntitlement| { &m.seen },
                |m: &mut RegisteredDownloadableEntitlement| { &mut m.seen },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RegisteredDownloadableEntitlement>(
                "RegisteredDownloadableEntitlement",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RegisteredDownloadableEntitlement {
        static instance: ::protobuf::rt::LazyV2<RegisteredDownloadableEntitlement> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RegisteredDownloadableEntitlement::new)
    }
}

impl ::protobuf::Clear for RegisteredDownloadableEntitlement {
    fn clear(&mut self) {
        self.id = 0;
        self.consumed = 0;
        self.registered = false;
        self.seen = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RegisteredDownloadableEntitlement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegisteredDownloadableEntitlement {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RegisteredDownloadableEntitlements {
    // message fields
    pub entitlement_source_asset_path: ::std::string::String,
    pub entitlement_ids: ::std::vec::Vec<i64>,
    pub entitlements: ::protobuf::RepeatedField<RegisteredDownloadableEntitlement>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RegisteredDownloadableEntitlements {
    fn default() -> &'a RegisteredDownloadableEntitlements {
        <RegisteredDownloadableEntitlements as ::protobuf::Message>::default_instance()
    }
}

impl RegisteredDownloadableEntitlements {
    pub fn new() -> RegisteredDownloadableEntitlements {
        ::std::default::Default::default()
    }

    // string entitlement_source_asset_path = 1;


    pub fn get_entitlement_source_asset_path(&self) -> &str {
        &self.entitlement_source_asset_path
    }
    pub fn clear_entitlement_source_asset_path(&mut self) {
        self.entitlement_source_asset_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_entitlement_source_asset_path(&mut self, v: ::std::string::String) {
        self.entitlement_source_asset_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entitlement_source_asset_path(&mut self) -> &mut ::std::string::String {
        &mut self.entitlement_source_asset_path
    }

    // Take field
    pub fn take_entitlement_source_asset_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entitlement_source_asset_path, ::std::string::String::new())
    }

    // repeated int64 entitlement_ids = 2;


    pub fn get_entitlement_ids(&self) -> &[i64] {
        &self.entitlement_ids
    }
    pub fn clear_entitlement_ids(&mut self) {
        self.entitlement_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_entitlement_ids(&mut self, v: ::std::vec::Vec<i64>) {
        self.entitlement_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entitlement_ids(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.entitlement_ids
    }

    // Take field
    pub fn take_entitlement_ids(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.entitlement_ids, ::std::vec::Vec::new())
    }

    // repeated .OakSave.RegisteredDownloadableEntitlement entitlements = 3;


    pub fn get_entitlements(&self) -> &[RegisteredDownloadableEntitlement] {
        &self.entitlements
    }
    pub fn clear_entitlements(&mut self) {
        self.entitlements.clear();
    }

    // Param is passed by value, moved
    pub fn set_entitlements(&mut self, v: ::protobuf::RepeatedField<RegisteredDownloadableEntitlement>) {
        self.entitlements = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entitlements(&mut self) -> &mut ::protobuf::RepeatedField<RegisteredDownloadableEntitlement> {
        &mut self.entitlements
    }

    // Take field
    pub fn take_entitlements(&mut self) -> ::protobuf::RepeatedField<RegisteredDownloadableEntitlement> {
        ::std::mem::replace(&mut self.entitlements, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RegisteredDownloadableEntitlements {
    fn is_initialized(&self) -> bool {
        for v in &self.entitlements {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entitlement_source_asset_path)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.entitlement_ids)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entitlements)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.entitlement_source_asset_path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.entitlement_source_asset_path);
        }
        for value in &self.entitlement_ids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.entitlements {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.entitlement_source_asset_path.is_empty() {
            os.write_string(1, &self.entitlement_source_asset_path)?;
        }
        for v in &self.entitlement_ids {
            os.write_int64(2, *v)?;
        };
        for v in &self.entitlements {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RegisteredDownloadableEntitlements {
        RegisteredDownloadableEntitlements::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "entitlement_source_asset_path",
                |m: &RegisteredDownloadableEntitlements| { &m.entitlement_source_asset_path },
                |m: &mut RegisteredDownloadableEntitlements| { &mut m.entitlement_source_asset_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "entitlement_ids",
                |m: &RegisteredDownloadableEntitlements| { &m.entitlement_ids },
                |m: &mut RegisteredDownloadableEntitlements| { &mut m.entitlement_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RegisteredDownloadableEntitlement>>(
                "entitlements",
                |m: &RegisteredDownloadableEntitlements| { &m.entitlements },
                |m: &mut RegisteredDownloadableEntitlements| { &mut m.entitlements },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RegisteredDownloadableEntitlements>(
                "RegisteredDownloadableEntitlements",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RegisteredDownloadableEntitlements {
        static instance: ::protobuf::rt::LazyV2<RegisteredDownloadableEntitlements> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RegisteredDownloadableEntitlements::new)
    }
}

impl ::protobuf::Clear for RegisteredDownloadableEntitlements {
    fn clear(&mut self) {
        self.entitlement_source_asset_path.clear();
        self.entitlement_ids.clear();
        self.entitlements.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RegisteredDownloadableEntitlements {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegisteredDownloadableEntitlements {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChallengeStatSaveGameData {
    // message fields
    pub current_stat_value: i32,
    pub challenge_stat_path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChallengeStatSaveGameData {
    fn default() -> &'a ChallengeStatSaveGameData {
        <ChallengeStatSaveGameData as ::protobuf::Message>::default_instance()
    }
}

impl ChallengeStatSaveGameData {
    pub fn new() -> ChallengeStatSaveGameData {
        ::std::default::Default::default()
    }

    // int32 current_stat_value = 1;


    pub fn get_current_stat_value(&self) -> i32 {
        self.current_stat_value
    }
    pub fn clear_current_stat_value(&mut self) {
        self.current_stat_value = 0;
    }

    // Param is passed by value, moved
    pub fn set_current_stat_value(&mut self, v: i32) {
        self.current_stat_value = v;
    }

    // string challenge_stat_path = 2;


    pub fn get_challenge_stat_path(&self) -> &str {
        &self.challenge_stat_path
    }
    pub fn clear_challenge_stat_path(&mut self) {
        self.challenge_stat_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_challenge_stat_path(&mut self, v: ::std::string::String) {
        self.challenge_stat_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_challenge_stat_path(&mut self) -> &mut ::std::string::String {
        &mut self.challenge_stat_path
    }

    // Take field
    pub fn take_challenge_stat_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.challenge_stat_path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ChallengeStatSaveGameData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.current_stat_value = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.challenge_stat_path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.current_stat_value != 0 {
            my_size += ::protobuf::rt::value_size(1, self.current_stat_value, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.challenge_stat_path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.challenge_stat_path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.current_stat_value != 0 {
            os.write_int32(1, self.current_stat_value)?;
        }
        if !self.challenge_stat_path.is_empty() {
            os.write_string(2, &self.challenge_stat_path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChallengeStatSaveGameData {
        ChallengeStatSaveGameData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "current_stat_value",
                |m: &ChallengeStatSaveGameData| { &m.current_stat_value },
                |m: &mut ChallengeStatSaveGameData| { &mut m.current_stat_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "challenge_stat_path",
                |m: &ChallengeStatSaveGameData| { &m.challenge_stat_path },
                |m: &mut ChallengeStatSaveGameData| { &mut m.challenge_stat_path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChallengeStatSaveGameData>(
                "ChallengeStatSaveGameData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChallengeStatSaveGameData {
        static instance: ::protobuf::rt::LazyV2<ChallengeStatSaveGameData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChallengeStatSaveGameData::new)
    }
}

impl ::protobuf::Clear for ChallengeStatSaveGameData {
    fn clear(&mut self) {
        self.current_stat_value = 0;
        self.challenge_stat_path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChallengeStatSaveGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChallengeStatSaveGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OakChallengeRewardSaveGameData {
    // message fields
    pub challenge_reward_claimed: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OakChallengeRewardSaveGameData {
    fn default() -> &'a OakChallengeRewardSaveGameData {
        <OakChallengeRewardSaveGameData as ::protobuf::Message>::default_instance()
    }
}

impl OakChallengeRewardSaveGameData {
    pub fn new() -> OakChallengeRewardSaveGameData {
        ::std::default::Default::default()
    }

    // bool challenge_reward_claimed = 1;


    pub fn get_challenge_reward_claimed(&self) -> bool {
        self.challenge_reward_claimed
    }
    pub fn clear_challenge_reward_claimed(&mut self) {
        self.challenge_reward_claimed = false;
    }

    // Param is passed by value, moved
    pub fn set_challenge_reward_claimed(&mut self, v: bool) {
        self.challenge_reward_claimed = v;
    }
}

impl ::protobuf::Message for OakChallengeRewardSaveGameData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.challenge_reward_claimed = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.challenge_reward_claimed != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.challenge_reward_claimed != false {
            os.write_bool(1, self.challenge_reward_claimed)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OakChallengeRewardSaveGameData {
        OakChallengeRewardSaveGameData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "challenge_reward_claimed",
                |m: &OakChallengeRewardSaveGameData| { &m.challenge_reward_claimed },
                |m: &mut OakChallengeRewardSaveGameData| { &mut m.challenge_reward_claimed },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OakChallengeRewardSaveGameData>(
                "OakChallengeRewardSaveGameData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OakChallengeRewardSaveGameData {
        static instance: ::protobuf::rt::LazyV2<OakChallengeRewardSaveGameData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OakChallengeRewardSaveGameData::new)
    }
}

impl ::protobuf::Clear for OakChallengeRewardSaveGameData {
    fn clear(&mut self) {
        self.challenge_reward_claimed = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OakChallengeRewardSaveGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OakChallengeRewardSaveGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChallengeSaveGameData {
    // message fields
    pub completed_count: i32,
    pub is_active: bool,
    pub currently_completed: bool,
    pub completed_progress_level: i32,
    pub progress_counter: i32,
    pub stat_instance_state: ::protobuf::RepeatedField<ChallengeStatSaveGameData>,
    pub challenge_class_path: ::std::string::String,
    pub challenge_reward_info: ::protobuf::RepeatedField<OakChallengeRewardSaveGameData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChallengeSaveGameData {
    fn default() -> &'a ChallengeSaveGameData {
        <ChallengeSaveGameData as ::protobuf::Message>::default_instance()
    }
}

impl ChallengeSaveGameData {
    pub fn new() -> ChallengeSaveGameData {
        ::std::default::Default::default()
    }

    // int32 completed_count = 1;


    pub fn get_completed_count(&self) -> i32 {
        self.completed_count
    }
    pub fn clear_completed_count(&mut self) {
        self.completed_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_completed_count(&mut self, v: i32) {
        self.completed_count = v;
    }

    // bool is_active = 2;


    pub fn get_is_active(&self) -> bool {
        self.is_active
    }
    pub fn clear_is_active(&mut self) {
        self.is_active = false;
    }

    // Param is passed by value, moved
    pub fn set_is_active(&mut self, v: bool) {
        self.is_active = v;
    }

    // bool currently_completed = 3;


    pub fn get_currently_completed(&self) -> bool {
        self.currently_completed
    }
    pub fn clear_currently_completed(&mut self) {
        self.currently_completed = false;
    }

    // Param is passed by value, moved
    pub fn set_currently_completed(&mut self, v: bool) {
        self.currently_completed = v;
    }

    // int32 completed_progress_level = 4;


    pub fn get_completed_progress_level(&self) -> i32 {
        self.completed_progress_level
    }
    pub fn clear_completed_progress_level(&mut self) {
        self.completed_progress_level = 0;
    }

    // Param is passed by value, moved
    pub fn set_completed_progress_level(&mut self, v: i32) {
        self.completed_progress_level = v;
    }

    // int32 progress_counter = 5;


    pub fn get_progress_counter(&self) -> i32 {
        self.progress_counter
    }
    pub fn clear_progress_counter(&mut self) {
        self.progress_counter = 0;
    }

    // Param is passed by value, moved
    pub fn set_progress_counter(&mut self, v: i32) {
        self.progress_counter = v;
    }

    // repeated .OakSave.ChallengeStatSaveGameData stat_instance_state = 6;


    pub fn get_stat_instance_state(&self) -> &[ChallengeStatSaveGameData] {
        &self.stat_instance_state
    }
    pub fn clear_stat_instance_state(&mut self) {
        self.stat_instance_state.clear();
    }

    // Param is passed by value, moved
    pub fn set_stat_instance_state(&mut self, v: ::protobuf::RepeatedField<ChallengeStatSaveGameData>) {
        self.stat_instance_state = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stat_instance_state(&mut self) -> &mut ::protobuf::RepeatedField<ChallengeStatSaveGameData> {
        &mut self.stat_instance_state
    }

    // Take field
    pub fn take_stat_instance_state(&mut self) -> ::protobuf::RepeatedField<ChallengeStatSaveGameData> {
        ::std::mem::replace(&mut self.stat_instance_state, ::protobuf::RepeatedField::new())
    }

    // string challenge_class_path = 7;


    pub fn get_challenge_class_path(&self) -> &str {
        &self.challenge_class_path
    }
    pub fn clear_challenge_class_path(&mut self) {
        self.challenge_class_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_challenge_class_path(&mut self, v: ::std::string::String) {
        self.challenge_class_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_challenge_class_path(&mut self) -> &mut ::std::string::String {
        &mut self.challenge_class_path
    }

    // Take field
    pub fn take_challenge_class_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.challenge_class_path, ::std::string::String::new())
    }

    // repeated .OakSave.OakChallengeRewardSaveGameData challenge_reward_info = 8;


    pub fn get_challenge_reward_info(&self) -> &[OakChallengeRewardSaveGameData] {
        &self.challenge_reward_info
    }
    pub fn clear_challenge_reward_info(&mut self) {
        self.challenge_reward_info.clear();
    }

    // Param is passed by value, moved
    pub fn set_challenge_reward_info(&mut self, v: ::protobuf::RepeatedField<OakChallengeRewardSaveGameData>) {
        self.challenge_reward_info = v;
    }

    // Mutable pointer to the field.
    pub fn mut_challenge_reward_info(&mut self) -> &mut ::protobuf::RepeatedField<OakChallengeRewardSaveGameData> {
        &mut self.challenge_reward_info
    }

    // Take field
    pub fn take_challenge_reward_info(&mut self) -> ::protobuf::RepeatedField<OakChallengeRewardSaveGameData> {
        ::std::mem::replace(&mut self.challenge_reward_info, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ChallengeSaveGameData {
    fn is_initialized(&self) -> bool {
        for v in &self.stat_instance_state {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.challenge_reward_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.completed_count = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_active = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.currently_completed = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.completed_progress_level = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.progress_counter = tmp;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stat_instance_state)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.challenge_class_path)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.challenge_reward_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.completed_count != 0 {
            my_size += ::protobuf::rt::value_size(1, self.completed_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.is_active != false {
            my_size += 2;
        }
        if self.currently_completed != false {
            my_size += 2;
        }
        if self.completed_progress_level != 0 {
            my_size += ::protobuf::rt::value_size(4, self.completed_progress_level, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.progress_counter != 0 {
            my_size += ::protobuf::rt::value_size(5, self.progress_counter, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.stat_instance_state {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.challenge_class_path.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.challenge_class_path);
        }
        for value in &self.challenge_reward_info {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.completed_count != 0 {
            os.write_int32(1, self.completed_count)?;
        }
        if self.is_active != false {
            os.write_bool(2, self.is_active)?;
        }
        if self.currently_completed != false {
            os.write_bool(3, self.currently_completed)?;
        }
        if self.completed_progress_level != 0 {
            os.write_int32(4, self.completed_progress_level)?;
        }
        if self.progress_counter != 0 {
            os.write_int32(5, self.progress_counter)?;
        }
        for v in &self.stat_instance_state {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.challenge_class_path.is_empty() {
            os.write_string(7, &self.challenge_class_path)?;
        }
        for v in &self.challenge_reward_info {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChallengeSaveGameData {
        ChallengeSaveGameData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "completed_count",
                |m: &ChallengeSaveGameData| { &m.completed_count },
                |m: &mut ChallengeSaveGameData| { &mut m.completed_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_active",
                |m: &ChallengeSaveGameData| { &m.is_active },
                |m: &mut ChallengeSaveGameData| { &mut m.is_active },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "currently_completed",
                |m: &ChallengeSaveGameData| { &m.currently_completed },
                |m: &mut ChallengeSaveGameData| { &mut m.currently_completed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "completed_progress_level",
                |m: &ChallengeSaveGameData| { &m.completed_progress_level },
                |m: &mut ChallengeSaveGameData| { &mut m.completed_progress_level },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "progress_counter",
                |m: &ChallengeSaveGameData| { &m.progress_counter },
                |m: &mut ChallengeSaveGameData| { &mut m.progress_counter },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChallengeStatSaveGameData>>(
                "stat_instance_state",
                |m: &ChallengeSaveGameData| { &m.stat_instance_state },
                |m: &mut ChallengeSaveGameData| { &mut m.stat_instance_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "challenge_class_path",
                |m: &ChallengeSaveGameData| { &m.challenge_class_path },
                |m: &mut ChallengeSaveGameData| { &mut m.challenge_class_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OakChallengeRewardSaveGameData>>(
                "challenge_reward_info",
                |m: &ChallengeSaveGameData| { &m.challenge_reward_info },
                |m: &mut ChallengeSaveGameData| { &mut m.challenge_reward_info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChallengeSaveGameData>(
                "ChallengeSaveGameData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChallengeSaveGameData {
        static instance: ::protobuf::rt::LazyV2<ChallengeSaveGameData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChallengeSaveGameData::new)
    }
}

impl ::protobuf::Clear for ChallengeSaveGameData {
    fn clear(&mut self) {
        self.completed_count = 0;
        self.is_active = false;
        self.currently_completed = false;
        self.completed_progress_level = 0;
        self.progress_counter = 0;
        self.stat_instance_state.clear();
        self.challenge_class_path.clear();
        self.challenge_reward_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChallengeSaveGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChallengeSaveGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OakMailItem {
    // message fields
    pub mail_item_type: u32,
    pub sender_display_name: ::std::string::String,
    pub subject: ::std::string::String,
    pub body: ::std::string::String,
    pub gear_serial_number: ::std::string::String,
    pub mail_guid: ::std::string::String,
    pub date_sent: i64,
    pub expiration_date: i64,
    pub from_player_id: ::std::string::String,
    pub has_been_read: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OakMailItem {
    fn default() -> &'a OakMailItem {
        <OakMailItem as ::protobuf::Message>::default_instance()
    }
}

impl OakMailItem {
    pub fn new() -> OakMailItem {
        ::std::default::Default::default()
    }

    // uint32 mail_item_type = 1;


    pub fn get_mail_item_type(&self) -> u32 {
        self.mail_item_type
    }
    pub fn clear_mail_item_type(&mut self) {
        self.mail_item_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_mail_item_type(&mut self, v: u32) {
        self.mail_item_type = v;
    }

    // string sender_display_name = 2;


    pub fn get_sender_display_name(&self) -> &str {
        &self.sender_display_name
    }
    pub fn clear_sender_display_name(&mut self) {
        self.sender_display_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender_display_name(&mut self, v: ::std::string::String) {
        self.sender_display_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender_display_name(&mut self) -> &mut ::std::string::String {
        &mut self.sender_display_name
    }

    // Take field
    pub fn take_sender_display_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender_display_name, ::std::string::String::new())
    }

    // string subject = 3;


    pub fn get_subject(&self) -> &str {
        &self.subject
    }
    pub fn clear_subject(&mut self) {
        self.subject.clear();
    }

    // Param is passed by value, moved
    pub fn set_subject(&mut self, v: ::std::string::String) {
        self.subject = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subject(&mut self) -> &mut ::std::string::String {
        &mut self.subject
    }

    // Take field
    pub fn take_subject(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subject, ::std::string::String::new())
    }

    // string body = 4;


    pub fn get_body(&self) -> &str {
        &self.body
    }
    pub fn clear_body(&mut self) {
        self.body.clear();
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::string::String) {
        self.body = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::string::String {
        &mut self.body
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.body, ::std::string::String::new())
    }

    // string gear_serial_number = 5;


    pub fn get_gear_serial_number(&self) -> &str {
        &self.gear_serial_number
    }
    pub fn clear_gear_serial_number(&mut self) {
        self.gear_serial_number.clear();
    }

    // Param is passed by value, moved
    pub fn set_gear_serial_number(&mut self, v: ::std::string::String) {
        self.gear_serial_number = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gear_serial_number(&mut self) -> &mut ::std::string::String {
        &mut self.gear_serial_number
    }

    // Take field
    pub fn take_gear_serial_number(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.gear_serial_number, ::std::string::String::new())
    }

    // string mail_guid = 6;


    pub fn get_mail_guid(&self) -> &str {
        &self.mail_guid
    }
    pub fn clear_mail_guid(&mut self) {
        self.mail_guid.clear();
    }

    // Param is passed by value, moved
    pub fn set_mail_guid(&mut self, v: ::std::string::String) {
        self.mail_guid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mail_guid(&mut self) -> &mut ::std::string::String {
        &mut self.mail_guid
    }

    // Take field
    pub fn take_mail_guid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mail_guid, ::std::string::String::new())
    }

    // int64 date_sent = 7;


    pub fn get_date_sent(&self) -> i64 {
        self.date_sent
    }
    pub fn clear_date_sent(&mut self) {
        self.date_sent = 0;
    }

    // Param is passed by value, moved
    pub fn set_date_sent(&mut self, v: i64) {
        self.date_sent = v;
    }

    // int64 expiration_date = 8;


    pub fn get_expiration_date(&self) -> i64 {
        self.expiration_date
    }
    pub fn clear_expiration_date(&mut self) {
        self.expiration_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_expiration_date(&mut self, v: i64) {
        self.expiration_date = v;
    }

    // string from_player_id = 9;


    pub fn get_from_player_id(&self) -> &str {
        &self.from_player_id
    }
    pub fn clear_from_player_id(&mut self) {
        self.from_player_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_from_player_id(&mut self, v: ::std::string::String) {
        self.from_player_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from_player_id(&mut self) -> &mut ::std::string::String {
        &mut self.from_player_id
    }

    // Take field
    pub fn take_from_player_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.from_player_id, ::std::string::String::new())
    }

    // bool has_been_read = 10;


    pub fn get_has_been_read(&self) -> bool {
        self.has_been_read
    }
    pub fn clear_has_been_read(&mut self) {
        self.has_been_read = false;
    }

    // Param is passed by value, moved
    pub fn set_has_been_read(&mut self, v: bool) {
        self.has_been_read = v;
    }
}

impl ::protobuf::Message for OakMailItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mail_item_type = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender_display_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subject)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.body)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.gear_serial_number)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.mail_guid)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.date_sent = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expiration_date = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.from_player_id)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_been_read = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.mail_item_type != 0 {
            my_size += ::protobuf::rt::value_size(1, self.mail_item_type, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.sender_display_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.sender_display_name);
        }
        if !self.subject.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.subject);
        }
        if !self.body.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.body);
        }
        if !self.gear_serial_number.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.gear_serial_number);
        }
        if !self.mail_guid.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.mail_guid);
        }
        if self.date_sent != 0 {
            my_size += ::protobuf::rt::value_size(7, self.date_sent, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.expiration_date != 0 {
            my_size += ::protobuf::rt::value_size(8, self.expiration_date, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.from_player_id.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.from_player_id);
        }
        if self.has_been_read != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.mail_item_type != 0 {
            os.write_uint32(1, self.mail_item_type)?;
        }
        if !self.sender_display_name.is_empty() {
            os.write_string(2, &self.sender_display_name)?;
        }
        if !self.subject.is_empty() {
            os.write_string(3, &self.subject)?;
        }
        if !self.body.is_empty() {
            os.write_string(4, &self.body)?;
        }
        if !self.gear_serial_number.is_empty() {
            os.write_string(5, &self.gear_serial_number)?;
        }
        if !self.mail_guid.is_empty() {
            os.write_string(6, &self.mail_guid)?;
        }
        if self.date_sent != 0 {
            os.write_int64(7, self.date_sent)?;
        }
        if self.expiration_date != 0 {
            os.write_int64(8, self.expiration_date)?;
        }
        if !self.from_player_id.is_empty() {
            os.write_string(9, &self.from_player_id)?;
        }
        if self.has_been_read != false {
            os.write_bool(10, self.has_been_read)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OakMailItem {
        OakMailItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "mail_item_type",
                |m: &OakMailItem| { &m.mail_item_type },
                |m: &mut OakMailItem| { &mut m.mail_item_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sender_display_name",
                |m: &OakMailItem| { &m.sender_display_name },
                |m: &mut OakMailItem| { &mut m.sender_display_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subject",
                |m: &OakMailItem| { &m.subject },
                |m: &mut OakMailItem| { &mut m.subject },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "body",
                |m: &OakMailItem| { &m.body },
                |m: &mut OakMailItem| { &mut m.body },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "gear_serial_number",
                |m: &OakMailItem| { &m.gear_serial_number },
                |m: &mut OakMailItem| { &mut m.gear_serial_number },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mail_guid",
                |m: &OakMailItem| { &m.mail_guid },
                |m: &mut OakMailItem| { &mut m.mail_guid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "date_sent",
                |m: &OakMailItem| { &m.date_sent },
                |m: &mut OakMailItem| { &mut m.date_sent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "expiration_date",
                |m: &OakMailItem| { &m.expiration_date },
                |m: &mut OakMailItem| { &mut m.expiration_date },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "from_player_id",
                |m: &OakMailItem| { &m.from_player_id },
                |m: &mut OakMailItem| { &mut m.from_player_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_been_read",
                |m: &OakMailItem| { &m.has_been_read },
                |m: &mut OakMailItem| { &mut m.has_been_read },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OakMailItem>(
                "OakMailItem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OakMailItem {
        static instance: ::protobuf::rt::LazyV2<OakMailItem> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OakMailItem::new)
    }
}

impl ::protobuf::Clear for OakMailItem {
    fn clear(&mut self) {
        self.mail_item_type = 0;
        self.sender_display_name.clear();
        self.subject.clear();
        self.body.clear();
        self.gear_serial_number.clear();
        self.mail_guid.clear();
        self.date_sent = 0;
        self.expiration_date = 0;
        self.from_player_id.clear();
        self.has_been_read = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OakMailItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OakMailItem {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OakCustomizationSaveGameData {
    // message fields
    pub is_new: bool,
    pub customization_asset_path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OakCustomizationSaveGameData {
    fn default() -> &'a OakCustomizationSaveGameData {
        <OakCustomizationSaveGameData as ::protobuf::Message>::default_instance()
    }
}

impl OakCustomizationSaveGameData {
    pub fn new() -> OakCustomizationSaveGameData {
        ::std::default::Default::default()
    }

    // bool is_new = 1;


    pub fn get_is_new(&self) -> bool {
        self.is_new
    }
    pub fn clear_is_new(&mut self) {
        self.is_new = false;
    }

    // Param is passed by value, moved
    pub fn set_is_new(&mut self, v: bool) {
        self.is_new = v;
    }

    // string customization_asset_path = 2;


    pub fn get_customization_asset_path(&self) -> &str {
        &self.customization_asset_path
    }
    pub fn clear_customization_asset_path(&mut self) {
        self.customization_asset_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_customization_asset_path(&mut self, v: ::std::string::String) {
        self.customization_asset_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_customization_asset_path(&mut self) -> &mut ::std::string::String {
        &mut self.customization_asset_path
    }

    // Take field
    pub fn take_customization_asset_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.customization_asset_path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for OakCustomizationSaveGameData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_new = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.customization_asset_path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.is_new != false {
            my_size += 2;
        }
        if !self.customization_asset_path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.customization_asset_path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.is_new != false {
            os.write_bool(1, self.is_new)?;
        }
        if !self.customization_asset_path.is_empty() {
            os.write_string(2, &self.customization_asset_path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OakCustomizationSaveGameData {
        OakCustomizationSaveGameData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_new",
                |m: &OakCustomizationSaveGameData| { &m.is_new },
                |m: &mut OakCustomizationSaveGameData| { &mut m.is_new },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "customization_asset_path",
                |m: &OakCustomizationSaveGameData| { &m.customization_asset_path },
                |m: &mut OakCustomizationSaveGameData| { &mut m.customization_asset_path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OakCustomizationSaveGameData>(
                "OakCustomizationSaveGameData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OakCustomizationSaveGameData {
        static instance: ::protobuf::rt::LazyV2<OakCustomizationSaveGameData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OakCustomizationSaveGameData::new)
    }
}

impl ::protobuf::Clear for OakCustomizationSaveGameData {
    fn clear(&mut self) {
        self.is_new = false;
        self.customization_asset_path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OakCustomizationSaveGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OakCustomizationSaveGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OakInventoryCustomizationPartInfo {
    // message fields
    pub customization_part_hash: u32,
    pub is_new: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OakInventoryCustomizationPartInfo {
    fn default() -> &'a OakInventoryCustomizationPartInfo {
        <OakInventoryCustomizationPartInfo as ::protobuf::Message>::default_instance()
    }
}

impl OakInventoryCustomizationPartInfo {
    pub fn new() -> OakInventoryCustomizationPartInfo {
        ::std::default::Default::default()
    }

    // uint32 customization_part_hash = 1;


    pub fn get_customization_part_hash(&self) -> u32 {
        self.customization_part_hash
    }
    pub fn clear_customization_part_hash(&mut self) {
        self.customization_part_hash = 0;
    }

    // Param is passed by value, moved
    pub fn set_customization_part_hash(&mut self, v: u32) {
        self.customization_part_hash = v;
    }

    // bool is_new = 2;


    pub fn get_is_new(&self) -> bool {
        self.is_new
    }
    pub fn clear_is_new(&mut self) {
        self.is_new = false;
    }

    // Param is passed by value, moved
    pub fn set_is_new(&mut self, v: bool) {
        self.is_new = v;
    }
}

impl ::protobuf::Message for OakInventoryCustomizationPartInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.customization_part_hash = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_new = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.customization_part_hash != 0 {
            my_size += ::protobuf::rt::value_size(1, self.customization_part_hash, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.is_new != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.customization_part_hash != 0 {
            os.write_uint32(1, self.customization_part_hash)?;
        }
        if self.is_new != false {
            os.write_bool(2, self.is_new)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OakInventoryCustomizationPartInfo {
        OakInventoryCustomizationPartInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "customization_part_hash",
                |m: &OakInventoryCustomizationPartInfo| { &m.customization_part_hash },
                |m: &mut OakInventoryCustomizationPartInfo| { &mut m.customization_part_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_new",
                |m: &OakInventoryCustomizationPartInfo| { &m.is_new },
                |m: &mut OakInventoryCustomizationPartInfo| { &mut m.is_new },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OakInventoryCustomizationPartInfo>(
                "OakInventoryCustomizationPartInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OakInventoryCustomizationPartInfo {
        static instance: ::protobuf::rt::LazyV2<OakInventoryCustomizationPartInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OakInventoryCustomizationPartInfo::new)
    }
}

impl ::protobuf::Clear for OakInventoryCustomizationPartInfo {
    fn clear(&mut self) {
        self.customization_part_hash = 0;
        self.is_new = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OakInventoryCustomizationPartInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OakInventoryCustomizationPartInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CrewQuartersDecorationItemSaveGameData {
    // message fields
    pub is_new: bool,
    pub decoration_item_asset_path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CrewQuartersDecorationItemSaveGameData {
    fn default() -> &'a CrewQuartersDecorationItemSaveGameData {
        <CrewQuartersDecorationItemSaveGameData as ::protobuf::Message>::default_instance()
    }
}

impl CrewQuartersDecorationItemSaveGameData {
    pub fn new() -> CrewQuartersDecorationItemSaveGameData {
        ::std::default::Default::default()
    }

    // bool is_new = 1;


    pub fn get_is_new(&self) -> bool {
        self.is_new
    }
    pub fn clear_is_new(&mut self) {
        self.is_new = false;
    }

    // Param is passed by value, moved
    pub fn set_is_new(&mut self, v: bool) {
        self.is_new = v;
    }

    // string decoration_item_asset_path = 2;


    pub fn get_decoration_item_asset_path(&self) -> &str {
        &self.decoration_item_asset_path
    }
    pub fn clear_decoration_item_asset_path(&mut self) {
        self.decoration_item_asset_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_decoration_item_asset_path(&mut self, v: ::std::string::String) {
        self.decoration_item_asset_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_decoration_item_asset_path(&mut self) -> &mut ::std::string::String {
        &mut self.decoration_item_asset_path
    }

    // Take field
    pub fn take_decoration_item_asset_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.decoration_item_asset_path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CrewQuartersDecorationItemSaveGameData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_new = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.decoration_item_asset_path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.is_new != false {
            my_size += 2;
        }
        if !self.decoration_item_asset_path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.decoration_item_asset_path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.is_new != false {
            os.write_bool(1, self.is_new)?;
        }
        if !self.decoration_item_asset_path.is_empty() {
            os.write_string(2, &self.decoration_item_asset_path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CrewQuartersDecorationItemSaveGameData {
        CrewQuartersDecorationItemSaveGameData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_new",
                |m: &CrewQuartersDecorationItemSaveGameData| { &m.is_new },
                |m: &mut CrewQuartersDecorationItemSaveGameData| { &mut m.is_new },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "decoration_item_asset_path",
                |m: &CrewQuartersDecorationItemSaveGameData| { &m.decoration_item_asset_path },
                |m: &mut CrewQuartersDecorationItemSaveGameData| { &mut m.decoration_item_asset_path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CrewQuartersDecorationItemSaveGameData>(
                "CrewQuartersDecorationItemSaveGameData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CrewQuartersDecorationItemSaveGameData {
        static instance: ::protobuf::rt::LazyV2<CrewQuartersDecorationItemSaveGameData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CrewQuartersDecorationItemSaveGameData::new)
    }
}

impl ::protobuf::Clear for CrewQuartersDecorationItemSaveGameData {
    fn clear(&mut self) {
        self.is_new = false;
        self.decoration_item_asset_path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CrewQuartersDecorationItemSaveGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CrewQuartersDecorationItemSaveGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CrewQuartersRoomItemSaveGameData {
    // message fields
    pub is_new: bool,
    pub room_item_asset_path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CrewQuartersRoomItemSaveGameData {
    fn default() -> &'a CrewQuartersRoomItemSaveGameData {
        <CrewQuartersRoomItemSaveGameData as ::protobuf::Message>::default_instance()
    }
}

impl CrewQuartersRoomItemSaveGameData {
    pub fn new() -> CrewQuartersRoomItemSaveGameData {
        ::std::default::Default::default()
    }

    // bool is_new = 1;


    pub fn get_is_new(&self) -> bool {
        self.is_new
    }
    pub fn clear_is_new(&mut self) {
        self.is_new = false;
    }

    // Param is passed by value, moved
    pub fn set_is_new(&mut self, v: bool) {
        self.is_new = v;
    }

    // string room_item_asset_path = 2;


    pub fn get_room_item_asset_path(&self) -> &str {
        &self.room_item_asset_path
    }
    pub fn clear_room_item_asset_path(&mut self) {
        self.room_item_asset_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_room_item_asset_path(&mut self, v: ::std::string::String) {
        self.room_item_asset_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_room_item_asset_path(&mut self) -> &mut ::std::string::String {
        &mut self.room_item_asset_path
    }

    // Take field
    pub fn take_room_item_asset_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.room_item_asset_path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CrewQuartersRoomItemSaveGameData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_new = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.room_item_asset_path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.is_new != false {
            my_size += 2;
        }
        if !self.room_item_asset_path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.room_item_asset_path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.is_new != false {
            os.write_bool(1, self.is_new)?;
        }
        if !self.room_item_asset_path.is_empty() {
            os.write_string(2, &self.room_item_asset_path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CrewQuartersRoomItemSaveGameData {
        CrewQuartersRoomItemSaveGameData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_new",
                |m: &CrewQuartersRoomItemSaveGameData| { &m.is_new },
                |m: &mut CrewQuartersRoomItemSaveGameData| { &mut m.is_new },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "room_item_asset_path",
                |m: &CrewQuartersRoomItemSaveGameData| { &m.room_item_asset_path },
                |m: &mut CrewQuartersRoomItemSaveGameData| { &mut m.room_item_asset_path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CrewQuartersRoomItemSaveGameData>(
                "CrewQuartersRoomItemSaveGameData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CrewQuartersRoomItemSaveGameData {
        static instance: ::protobuf::rt::LazyV2<CrewQuartersRoomItemSaveGameData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CrewQuartersRoomItemSaveGameData::new)
    }
}

impl ::protobuf::Clear for CrewQuartersRoomItemSaveGameData {
    fn clear(&mut self) {
        self.is_new = false;
        self.room_item_asset_path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CrewQuartersRoomItemSaveGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CrewQuartersRoomItemSaveGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VaultCardSaveGameData {
    // message fields
    pub last_active_vault_card_id: u32,
    pub current_day_seed: i32,
    pub current_week_seed: i32,
    pub vault_card_previous_challenges: ::protobuf::RepeatedField<VaultCardPreviousChallenge>,
    pub vault_card_claimed_rewards: ::protobuf::RepeatedField<VaultCardRewardList>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VaultCardSaveGameData {
    fn default() -> &'a VaultCardSaveGameData {
        <VaultCardSaveGameData as ::protobuf::Message>::default_instance()
    }
}

impl VaultCardSaveGameData {
    pub fn new() -> VaultCardSaveGameData {
        ::std::default::Default::default()
    }

    // uint32 last_active_vault_card_id = 2;


    pub fn get_last_active_vault_card_id(&self) -> u32 {
        self.last_active_vault_card_id
    }
    pub fn clear_last_active_vault_card_id(&mut self) {
        self.last_active_vault_card_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_active_vault_card_id(&mut self, v: u32) {
        self.last_active_vault_card_id = v;
    }

    // int32 current_day_seed = 3;


    pub fn get_current_day_seed(&self) -> i32 {
        self.current_day_seed
    }
    pub fn clear_current_day_seed(&mut self) {
        self.current_day_seed = 0;
    }

    // Param is passed by value, moved
    pub fn set_current_day_seed(&mut self, v: i32) {
        self.current_day_seed = v;
    }

    // int32 current_week_seed = 4;


    pub fn get_current_week_seed(&self) -> i32 {
        self.current_week_seed
    }
    pub fn clear_current_week_seed(&mut self) {
        self.current_week_seed = 0;
    }

    // Param is passed by value, moved
    pub fn set_current_week_seed(&mut self, v: i32) {
        self.current_week_seed = v;
    }

    // repeated .OakSave.VaultCardPreviousChallenge vault_card_previous_challenges = 5;


    pub fn get_vault_card_previous_challenges(&self) -> &[VaultCardPreviousChallenge] {
        &self.vault_card_previous_challenges
    }
    pub fn clear_vault_card_previous_challenges(&mut self) {
        self.vault_card_previous_challenges.clear();
    }

    // Param is passed by value, moved
    pub fn set_vault_card_previous_challenges(&mut self, v: ::protobuf::RepeatedField<VaultCardPreviousChallenge>) {
        self.vault_card_previous_challenges = v;
    }

    // Mutable pointer to the field.
    pub fn mut_vault_card_previous_challenges(&mut self) -> &mut ::protobuf::RepeatedField<VaultCardPreviousChallenge> {
        &mut self.vault_card_previous_challenges
    }

    // Take field
    pub fn take_vault_card_previous_challenges(&mut self) -> ::protobuf::RepeatedField<VaultCardPreviousChallenge> {
        ::std::mem::replace(&mut self.vault_card_previous_challenges, ::protobuf::RepeatedField::new())
    }

    // repeated .OakSave.VaultCardRewardList vault_card_claimed_rewards = 6;


    pub fn get_vault_card_claimed_rewards(&self) -> &[VaultCardRewardList] {
        &self.vault_card_claimed_rewards
    }
    pub fn clear_vault_card_claimed_rewards(&mut self) {
        self.vault_card_claimed_rewards.clear();
    }

    // Param is passed by value, moved
    pub fn set_vault_card_claimed_rewards(&mut self, v: ::protobuf::RepeatedField<VaultCardRewardList>) {
        self.vault_card_claimed_rewards = v;
    }

    // Mutable pointer to the field.
    pub fn mut_vault_card_claimed_rewards(&mut self) -> &mut ::protobuf::RepeatedField<VaultCardRewardList> {
        &mut self.vault_card_claimed_rewards
    }

    // Take field
    pub fn take_vault_card_claimed_rewards(&mut self) -> ::protobuf::RepeatedField<VaultCardRewardList> {
        ::std::mem::replace(&mut self.vault_card_claimed_rewards, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for VaultCardSaveGameData {
    fn is_initialized(&self) -> bool {
        for v in &self.vault_card_previous_challenges {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.vault_card_claimed_rewards {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_active_vault_card_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.current_day_seed = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.current_week_seed = tmp;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.vault_card_previous_challenges)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.vault_card_claimed_rewards)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.last_active_vault_card_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.last_active_vault_card_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.current_day_seed != 0 {
            my_size += ::protobuf::rt::value_size(3, self.current_day_seed, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.current_week_seed != 0 {
            my_size += ::protobuf::rt::value_size(4, self.current_week_seed, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.vault_card_previous_challenges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.vault_card_claimed_rewards {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.last_active_vault_card_id != 0 {
            os.write_uint32(2, self.last_active_vault_card_id)?;
        }
        if self.current_day_seed != 0 {
            os.write_int32(3, self.current_day_seed)?;
        }
        if self.current_week_seed != 0 {
            os.write_int32(4, self.current_week_seed)?;
        }
        for v in &self.vault_card_previous_challenges {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.vault_card_claimed_rewards {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VaultCardSaveGameData {
        VaultCardSaveGameData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "last_active_vault_card_id",
                |m: &VaultCardSaveGameData| { &m.last_active_vault_card_id },
                |m: &mut VaultCardSaveGameData| { &mut m.last_active_vault_card_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "current_day_seed",
                |m: &VaultCardSaveGameData| { &m.current_day_seed },
                |m: &mut VaultCardSaveGameData| { &mut m.current_day_seed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "current_week_seed",
                |m: &VaultCardSaveGameData| { &m.current_week_seed },
                |m: &mut VaultCardSaveGameData| { &mut m.current_week_seed },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VaultCardPreviousChallenge>>(
                "vault_card_previous_challenges",
                |m: &VaultCardSaveGameData| { &m.vault_card_previous_challenges },
                |m: &mut VaultCardSaveGameData| { &mut m.vault_card_previous_challenges },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VaultCardRewardList>>(
                "vault_card_claimed_rewards",
                |m: &VaultCardSaveGameData| { &m.vault_card_claimed_rewards },
                |m: &mut VaultCardSaveGameData| { &mut m.vault_card_claimed_rewards },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VaultCardSaveGameData>(
                "VaultCardSaveGameData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VaultCardSaveGameData {
        static instance: ::protobuf::rt::LazyV2<VaultCardSaveGameData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VaultCardSaveGameData::new)
    }
}

impl ::protobuf::Clear for VaultCardSaveGameData {
    fn clear(&mut self) {
        self.last_active_vault_card_id = 0;
        self.current_day_seed = 0;
        self.current_week_seed = 0;
        self.vault_card_previous_challenges.clear();
        self.vault_card_claimed_rewards.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VaultCardSaveGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VaultCardSaveGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VaultCardReward {
    // message fields
    pub column_index: i32,
    pub row_index: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VaultCardReward {
    fn default() -> &'a VaultCardReward {
        <VaultCardReward as ::protobuf::Message>::default_instance()
    }
}

impl VaultCardReward {
    pub fn new() -> VaultCardReward {
        ::std::default::Default::default()
    }

    // int32 column_index = 1;


    pub fn get_column_index(&self) -> i32 {
        self.column_index
    }
    pub fn clear_column_index(&mut self) {
        self.column_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_column_index(&mut self, v: i32) {
        self.column_index = v;
    }

    // int32 row_index = 2;


    pub fn get_row_index(&self) -> i32 {
        self.row_index
    }
    pub fn clear_row_index(&mut self) {
        self.row_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_row_index(&mut self, v: i32) {
        self.row_index = v;
    }
}

impl ::protobuf::Message for VaultCardReward {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.column_index = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.row_index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.column_index != 0 {
            my_size += ::protobuf::rt::value_size(1, self.column_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.row_index != 0 {
            my_size += ::protobuf::rt::value_size(2, self.row_index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.column_index != 0 {
            os.write_int32(1, self.column_index)?;
        }
        if self.row_index != 0 {
            os.write_int32(2, self.row_index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VaultCardReward {
        VaultCardReward::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "column_index",
                |m: &VaultCardReward| { &m.column_index },
                |m: &mut VaultCardReward| { &mut m.column_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "row_index",
                |m: &VaultCardReward| { &m.row_index },
                |m: &mut VaultCardReward| { &mut m.row_index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VaultCardReward>(
                "VaultCardReward",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VaultCardReward {
        static instance: ::protobuf::rt::LazyV2<VaultCardReward> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VaultCardReward::new)
    }
}

impl ::protobuf::Clear for VaultCardReward {
    fn clear(&mut self) {
        self.column_index = 0;
        self.row_index = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VaultCardReward {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VaultCardReward {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VaultCardGearReward {
    // message fields
    pub gear_index: i32,
    pub repurchase_count: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VaultCardGearReward {
    fn default() -> &'a VaultCardGearReward {
        <VaultCardGearReward as ::protobuf::Message>::default_instance()
    }
}

impl VaultCardGearReward {
    pub fn new() -> VaultCardGearReward {
        ::std::default::Default::default()
    }

    // int32 gear_index = 1;


    pub fn get_gear_index(&self) -> i32 {
        self.gear_index
    }
    pub fn clear_gear_index(&mut self) {
        self.gear_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_gear_index(&mut self, v: i32) {
        self.gear_index = v;
    }

    // uint32 repurchase_count = 2;


    pub fn get_repurchase_count(&self) -> u32 {
        self.repurchase_count
    }
    pub fn clear_repurchase_count(&mut self) {
        self.repurchase_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_repurchase_count(&mut self, v: u32) {
        self.repurchase_count = v;
    }
}

impl ::protobuf::Message for VaultCardGearReward {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.gear_index = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.repurchase_count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.gear_index != 0 {
            my_size += ::protobuf::rt::value_size(1, self.gear_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.repurchase_count != 0 {
            my_size += ::protobuf::rt::value_size(2, self.repurchase_count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.gear_index != 0 {
            os.write_int32(1, self.gear_index)?;
        }
        if self.repurchase_count != 0 {
            os.write_uint32(2, self.repurchase_count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VaultCardGearReward {
        VaultCardGearReward::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "gear_index",
                |m: &VaultCardGearReward| { &m.gear_index },
                |m: &mut VaultCardGearReward| { &mut m.gear_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "repurchase_count",
                |m: &VaultCardGearReward| { &m.repurchase_count },
                |m: &mut VaultCardGearReward| { &mut m.repurchase_count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VaultCardGearReward>(
                "VaultCardGearReward",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VaultCardGearReward {
        static instance: ::protobuf::rt::LazyV2<VaultCardGearReward> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VaultCardGearReward::new)
    }
}

impl ::protobuf::Clear for VaultCardGearReward {
    fn clear(&mut self) {
        self.gear_index = 0;
        self.repurchase_count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VaultCardGearReward {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VaultCardGearReward {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VaultCardRewardList {
    // message fields
    pub vault_card_id: u32,
    pub vault_card_experience: i64,
    pub unlocked_reward_list: ::protobuf::RepeatedField<VaultCardReward>,
    pub redeemed_reward_list: ::protobuf::RepeatedField<VaultCardReward>,
    pub vault_card_chests: i32,
    pub vault_card_chests_opened: u32,
    pub vault_card_keys_spent: u32,
    pub gear_rewards: ::protobuf::RepeatedField<VaultCardGearReward>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VaultCardRewardList {
    fn default() -> &'a VaultCardRewardList {
        <VaultCardRewardList as ::protobuf::Message>::default_instance()
    }
}

impl VaultCardRewardList {
    pub fn new() -> VaultCardRewardList {
        ::std::default::Default::default()
    }

    // uint32 vault_card_id = 1;


    pub fn get_vault_card_id(&self) -> u32 {
        self.vault_card_id
    }
    pub fn clear_vault_card_id(&mut self) {
        self.vault_card_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_vault_card_id(&mut self, v: u32) {
        self.vault_card_id = v;
    }

    // int64 vault_card_experience = 2;


    pub fn get_vault_card_experience(&self) -> i64 {
        self.vault_card_experience
    }
    pub fn clear_vault_card_experience(&mut self) {
        self.vault_card_experience = 0;
    }

    // Param is passed by value, moved
    pub fn set_vault_card_experience(&mut self, v: i64) {
        self.vault_card_experience = v;
    }

    // repeated .OakSave.VaultCardReward unlocked_reward_list = 4;


    pub fn get_unlocked_reward_list(&self) -> &[VaultCardReward] {
        &self.unlocked_reward_list
    }
    pub fn clear_unlocked_reward_list(&mut self) {
        self.unlocked_reward_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_unlocked_reward_list(&mut self, v: ::protobuf::RepeatedField<VaultCardReward>) {
        self.unlocked_reward_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unlocked_reward_list(&mut self) -> &mut ::protobuf::RepeatedField<VaultCardReward> {
        &mut self.unlocked_reward_list
    }

    // Take field
    pub fn take_unlocked_reward_list(&mut self) -> ::protobuf::RepeatedField<VaultCardReward> {
        ::std::mem::replace(&mut self.unlocked_reward_list, ::protobuf::RepeatedField::new())
    }

    // repeated .OakSave.VaultCardReward redeemed_reward_list = 5;


    pub fn get_redeemed_reward_list(&self) -> &[VaultCardReward] {
        &self.redeemed_reward_list
    }
    pub fn clear_redeemed_reward_list(&mut self) {
        self.redeemed_reward_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_redeemed_reward_list(&mut self, v: ::protobuf::RepeatedField<VaultCardReward>) {
        self.redeemed_reward_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_redeemed_reward_list(&mut self) -> &mut ::protobuf::RepeatedField<VaultCardReward> {
        &mut self.redeemed_reward_list
    }

    // Take field
    pub fn take_redeemed_reward_list(&mut self) -> ::protobuf::RepeatedField<VaultCardReward> {
        ::std::mem::replace(&mut self.redeemed_reward_list, ::protobuf::RepeatedField::new())
    }

    // int32 vault_card_chests = 7;


    pub fn get_vault_card_chests(&self) -> i32 {
        self.vault_card_chests
    }
    pub fn clear_vault_card_chests(&mut self) {
        self.vault_card_chests = 0;
    }

    // Param is passed by value, moved
    pub fn set_vault_card_chests(&mut self, v: i32) {
        self.vault_card_chests = v;
    }

    // uint32 vault_card_chests_opened = 8;


    pub fn get_vault_card_chests_opened(&self) -> u32 {
        self.vault_card_chests_opened
    }
    pub fn clear_vault_card_chests_opened(&mut self) {
        self.vault_card_chests_opened = 0;
    }

    // Param is passed by value, moved
    pub fn set_vault_card_chests_opened(&mut self, v: u32) {
        self.vault_card_chests_opened = v;
    }

    // uint32 vault_card_keys_spent = 9;


    pub fn get_vault_card_keys_spent(&self) -> u32 {
        self.vault_card_keys_spent
    }
    pub fn clear_vault_card_keys_spent(&mut self) {
        self.vault_card_keys_spent = 0;
    }

    // Param is passed by value, moved
    pub fn set_vault_card_keys_spent(&mut self, v: u32) {
        self.vault_card_keys_spent = v;
    }

    // repeated .OakSave.VaultCardGearReward gear_rewards = 10;


    pub fn get_gear_rewards(&self) -> &[VaultCardGearReward] {
        &self.gear_rewards
    }
    pub fn clear_gear_rewards(&mut self) {
        self.gear_rewards.clear();
    }

    // Param is passed by value, moved
    pub fn set_gear_rewards(&mut self, v: ::protobuf::RepeatedField<VaultCardGearReward>) {
        self.gear_rewards = v;
    }

    // Mutable pointer to the field.
    pub fn mut_gear_rewards(&mut self) -> &mut ::protobuf::RepeatedField<VaultCardGearReward> {
        &mut self.gear_rewards
    }

    // Take field
    pub fn take_gear_rewards(&mut self) -> ::protobuf::RepeatedField<VaultCardGearReward> {
        ::std::mem::replace(&mut self.gear_rewards, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for VaultCardRewardList {
    fn is_initialized(&self) -> bool {
        for v in &self.unlocked_reward_list {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.redeemed_reward_list {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.gear_rewards {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.vault_card_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.vault_card_experience = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.unlocked_reward_list)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.redeemed_reward_list)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.vault_card_chests = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.vault_card_chests_opened = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.vault_card_keys_spent = tmp;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.gear_rewards)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.vault_card_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.vault_card_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.vault_card_experience != 0 {
            my_size += ::protobuf::rt::value_size(2, self.vault_card_experience, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.unlocked_reward_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.redeemed_reward_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.vault_card_chests != 0 {
            my_size += ::protobuf::rt::value_size(7, self.vault_card_chests, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.vault_card_chests_opened != 0 {
            my_size += ::protobuf::rt::value_size(8, self.vault_card_chests_opened, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.vault_card_keys_spent != 0 {
            my_size += ::protobuf::rt::value_size(9, self.vault_card_keys_spent, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.gear_rewards {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.vault_card_id != 0 {
            os.write_uint32(1, self.vault_card_id)?;
        }
        if self.vault_card_experience != 0 {
            os.write_int64(2, self.vault_card_experience)?;
        }
        for v in &self.unlocked_reward_list {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.redeemed_reward_list {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.vault_card_chests != 0 {
            os.write_int32(7, self.vault_card_chests)?;
        }
        if self.vault_card_chests_opened != 0 {
            os.write_uint32(8, self.vault_card_chests_opened)?;
        }
        if self.vault_card_keys_spent != 0 {
            os.write_uint32(9, self.vault_card_keys_spent)?;
        }
        for v in &self.gear_rewards {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VaultCardRewardList {
        VaultCardRewardList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "vault_card_id",
                |m: &VaultCardRewardList| { &m.vault_card_id },
                |m: &mut VaultCardRewardList| { &mut m.vault_card_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "vault_card_experience",
                |m: &VaultCardRewardList| { &m.vault_card_experience },
                |m: &mut VaultCardRewardList| { &mut m.vault_card_experience },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VaultCardReward>>(
                "unlocked_reward_list",
                |m: &VaultCardRewardList| { &m.unlocked_reward_list },
                |m: &mut VaultCardRewardList| { &mut m.unlocked_reward_list },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VaultCardReward>>(
                "redeemed_reward_list",
                |m: &VaultCardRewardList| { &m.redeemed_reward_list },
                |m: &mut VaultCardRewardList| { &mut m.redeemed_reward_list },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "vault_card_chests",
                |m: &VaultCardRewardList| { &m.vault_card_chests },
                |m: &mut VaultCardRewardList| { &mut m.vault_card_chests },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "vault_card_chests_opened",
                |m: &VaultCardRewardList| { &m.vault_card_chests_opened },
                |m: &mut VaultCardRewardList| { &mut m.vault_card_chests_opened },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "vault_card_keys_spent",
                |m: &VaultCardRewardList| { &m.vault_card_keys_spent },
                |m: &mut VaultCardRewardList| { &mut m.vault_card_keys_spent },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VaultCardGearReward>>(
                "gear_rewards",
                |m: &VaultCardRewardList| { &m.gear_rewards },
                |m: &mut VaultCardRewardList| { &mut m.gear_rewards },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VaultCardRewardList>(
                "VaultCardRewardList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VaultCardRewardList {
        static instance: ::protobuf::rt::LazyV2<VaultCardRewardList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VaultCardRewardList::new)
    }
}

impl ::protobuf::Clear for VaultCardRewardList {
    fn clear(&mut self) {
        self.vault_card_id = 0;
        self.vault_card_experience = 0;
        self.unlocked_reward_list.clear();
        self.redeemed_reward_list.clear();
        self.vault_card_chests = 0;
        self.vault_card_chests_opened = 0;
        self.vault_card_keys_spent = 0;
        self.gear_rewards.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VaultCardRewardList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VaultCardRewardList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VaultCardPreviousChallenge {
    // message fields
    pub previous_challenge_seed: i32,
    pub previous_challenge_id: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VaultCardPreviousChallenge {
    fn default() -> &'a VaultCardPreviousChallenge {
        <VaultCardPreviousChallenge as ::protobuf::Message>::default_instance()
    }
}

impl VaultCardPreviousChallenge {
    pub fn new() -> VaultCardPreviousChallenge {
        ::std::default::Default::default()
    }

    // int32 previous_challenge_seed = 1;


    pub fn get_previous_challenge_seed(&self) -> i32 {
        self.previous_challenge_seed
    }
    pub fn clear_previous_challenge_seed(&mut self) {
        self.previous_challenge_seed = 0;
    }

    // Param is passed by value, moved
    pub fn set_previous_challenge_seed(&mut self, v: i32) {
        self.previous_challenge_seed = v;
    }

    // uint32 previous_challenge_id = 2;


    pub fn get_previous_challenge_id(&self) -> u32 {
        self.previous_challenge_id
    }
    pub fn clear_previous_challenge_id(&mut self) {
        self.previous_challenge_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_previous_challenge_id(&mut self, v: u32) {
        self.previous_challenge_id = v;
    }
}

impl ::protobuf::Message for VaultCardPreviousChallenge {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.previous_challenge_seed = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.previous_challenge_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.previous_challenge_seed != 0 {
            my_size += ::protobuf::rt::value_size(1, self.previous_challenge_seed, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.previous_challenge_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.previous_challenge_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.previous_challenge_seed != 0 {
            os.write_int32(1, self.previous_challenge_seed)?;
        }
        if self.previous_challenge_id != 0 {
            os.write_uint32(2, self.previous_challenge_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VaultCardPreviousChallenge {
        VaultCardPreviousChallenge::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "previous_challenge_seed",
                |m: &VaultCardPreviousChallenge| { &m.previous_challenge_seed },
                |m: &mut VaultCardPreviousChallenge| { &mut m.previous_challenge_seed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "previous_challenge_id",
                |m: &VaultCardPreviousChallenge| { &m.previous_challenge_id },
                |m: &mut VaultCardPreviousChallenge| { &mut m.previous_challenge_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VaultCardPreviousChallenge>(
                "VaultCardPreviousChallenge",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VaultCardPreviousChallenge {
        static instance: ::protobuf::rt::LazyV2<VaultCardPreviousChallenge> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VaultCardPreviousChallenge::new)
    }
}

impl ::protobuf::Clear for VaultCardPreviousChallenge {
    fn clear(&mut self) {
        self.previous_challenge_seed = 0;
        self.previous_challenge_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VaultCardPreviousChallenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VaultCardPreviousChallenge {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x10oak_shared.proto\x12\x07OakSave\"8\n\x04Vec3\x12\x0e\n\x01x\x18\
    \x01\x20\x01(\x02R\x01xB\0\x12\x0e\n\x01y\x18\x02\x20\x01(\x02R\x01yB\0\
    \x12\x0e\n\x01z\x18\x03\x20\x01(\x02R\x01zB\0:\0\"X\n\x14GameStatSaveGam\
    eData\x12\x1f\n\nstat_value\x18\x01\x20\x01(\x05R\tstatValueB\0\x12\x1d\
    \n\tstat_path\x18\x02\x20\x01(\tR\x08statPathB\0:\0\"\x80\x01\n\x19Inven\
    toryCategorySaveData\x12C\n\x1dbase_category_definition_hash\x18\x01\x20\
    \x01(\rR\x1abaseCategoryDefinitionHashB\0\x12\x1c\n\x08quantity\x18\x02\
    \x20\x01(\x05R\x08quantityB\0:\0\"[\n\x12OakSDUSaveGameData\x12\x1d\n\ts\
    du_level\x18\x01\x20\x01(\x05R\x08sduLevelB\0\x12$\n\rsdu_data_path\x18\
    \x02\x20\x01(\tR\x0bsduDataPathB\0:\0\"\x8d\x01\n!RegisteredDownloadable\
    Entitlement\x12\x10\n\x02id\x18\x01\x20\x01(\x05R\x02idB\0\x12\x1c\n\x08\
    consumed\x18\x02\x20\x01(\rR\x08consumedB\0\x12\x20\n\nregistered\x18\
    \x03\x20\x01(\x08R\nregisteredB\0\x12\x14\n\x04seen\x18\x04\x20\x01(\x08\
    R\x04seenB\0:\0\"\xe8\x01\n\"RegisteredDownloadableEntitlements\x12C\n\
    \x1dentitlement_source_asset_path\x18\x01\x20\x01(\tR\x1aentitlementSour\
    ceAssetPathB\0\x12)\n\x0fentitlement_ids\x18\x02\x20\x03(\x03R\x0eentitl\
    ementIdsB\0\x12P\n\x0centitlements\x18\x03\x20\x03(\x0b2*.OakSave.Regist\
    eredDownloadableEntitlementR\x0centitlementsB\0:\0\"\x7f\n\x19ChallengeS\
    tatSaveGameData\x12.\n\x12current_stat_value\x18\x01\x20\x01(\x05R\x10cu\
    rrentStatValueB\0\x120\n\x13challenge_stat_path\x18\x02\x20\x01(\tR\x11c\
    hallengeStatPathB\0:\0\"^\n\x1eOakChallengeRewardSaveGameData\x12:\n\x18\
    challenge_reward_claimed\x18\x01\x20\x01(\x08R\x16challengeRewardClaimed\
    B\0:\0\"\xe8\x03\n\x15ChallengeSaveGameData\x12)\n\x0fcompleted_count\
    \x18\x01\x20\x01(\x05R\x0ecompletedCountB\0\x12\x1d\n\tis_active\x18\x02\
    \x20\x01(\x08R\x08isActiveB\0\x121\n\x13currently_completed\x18\x03\x20\
    \x01(\x08R\x12currentlyCompletedB\0\x12:\n\x18completed_progress_level\
    \x18\x04\x20\x01(\x05R\x16completedProgressLevelB\0\x12+\n\x10progress_c\
    ounter\x18\x05\x20\x01(\x05R\x0fprogressCounterB\0\x12T\n\x13stat_instan\
    ce_state\x18\x06\x20\x03(\x0b2\".OakSave.ChallengeStatSaveGameDataR\x11s\
    tatInstanceStateB\0\x122\n\x14challenge_class_path\x18\x07\x20\x01(\tR\
    \x12challengeClassPathB\0\x12]\n\x15challenge_reward_info\x18\x08\x20\
    \x03(\x0b2'.OakSave.OakChallengeRewardSaveGameDataR\x13challengeRewardIn\
    foB\0:\0\"\x82\x03\n\x0bOakMailItem\x12&\n\x0email_item_type\x18\x01\x20\
    \x01(\rR\x0cmailItemTypeB\0\x120\n\x13sender_display_name\x18\x02\x20\
    \x01(\tR\x11senderDisplayNameB\0\x12\x1a\n\x07subject\x18\x03\x20\x01(\t\
    R\x07subjectB\0\x12\x14\n\x04body\x18\x04\x20\x01(\tR\x04bodyB\0\x12.\n\
    \x12gear_serial_number\x18\x05\x20\x01(\tR\x10gearSerialNumberB\0\x12\
    \x1d\n\tmail_guid\x18\x06\x20\x01(\tR\x08mailGuidB\0\x12\x1d\n\tdate_sen\
    t\x18\x07\x20\x01(\x03R\x08dateSentB\0\x12)\n\x0fexpiration_date\x18\x08\
    \x20\x01(\x03R\x0eexpirationDateB\0\x12&\n\x0efrom_player_id\x18\t\x20\
    \x01(\tR\x0cfromPlayerIdB\0\x12$\n\rhas_been_read\x18\n\x20\x01(\x08R\
    \x0bhasBeenReadB\0:\0\"u\n\x1cOakCustomizationSaveGameData\x12\x17\n\x06\
    is_new\x18\x01\x20\x01(\x08R\x05isNewB\0\x12:\n\x18customization_asset_p\
    ath\x18\x02\x20\x01(\tR\x16customizationAssetPathB\0:\0\"x\n!OakInventor\
    yCustomizationPartInfo\x128\n\x17customization_part_hash\x18\x01\x20\x01\
    (\rR\x15customizationPartHashB\0\x12\x17\n\x06is_new\x18\x02\x20\x01(\
    \x08R\x05isNewB\0:\0\"\x82\x01\n&CrewQuartersDecorationItemSaveGameData\
    \x12\x17\n\x06is_new\x18\x01\x20\x01(\x08R\x05isNewB\0\x12=\n\x1adecorat\
    ion_item_asset_path\x18\x02\x20\x01(\tR\x17decorationItemAssetPathB\0:\0\
    \"p\n\x20CrewQuartersRoomItemSaveGameData\x12\x17\n\x06is_new\x18\x01\
    \x20\x01(\x08R\x05isNewB\0\x121\n\x14room_item_asset_path\x18\x02\x20\
    \x01(\tR\x11roomItemAssetPathB\0:\0\"\xf8\x02\n\x15VaultCardSaveGameData\
    \x12:\n\x19last_active_vault_card_id\x18\x02\x20\x01(\rR\x15lastActiveVa\
    ultCardIdB\0\x12*\n\x10current_day_seed\x18\x03\x20\x01(\x05R\x0ecurrent\
    DaySeedB\0\x12,\n\x11current_week_seed\x18\x04\x20\x01(\x05R\x0fcurrentW\
    eekSeedB\0\x12j\n\x1evault_card_previous_challenges\x18\x05\x20\x03(\x0b\
    2#.OakSave.VaultCardPreviousChallengeR\x1bvaultCardPreviousChallengesB\0\
    \x12[\n\x1avault_card_claimed_rewards\x18\x06\x20\x03(\x0b2\x1c.OakSave.\
    VaultCardRewardListR\x17vaultCardClaimedRewardsB\0:\0\"W\n\x0fVaultCardR\
    eward\x12#\n\x0ccolumn_index\x18\x01\x20\x01(\x05R\x0bcolumnIndexB\0\x12\
    \x1d\n\trow_index\x18\x02\x20\x01(\x05R\x08rowIndexB\0:\0\"e\n\x13VaultC\
    ardGearReward\x12\x1f\n\ngear_index\x18\x01\x20\x01(\x05R\tgearIndexB\0\
    \x12+\n\x10repurchase_count\x18\x02\x20\x01(\rR\x0frepurchaseCountB\0:\0\
    \"\xf0\x03\n\x13VaultCardRewardList\x12$\n\rvault_card_id\x18\x01\x20\
    \x01(\rR\x0bvaultCardIdB\0\x124\n\x15vault_card_experience\x18\x02\x20\
    \x01(\x03R\x13vaultCardExperienceB\0\x12L\n\x14unlocked_reward_list\x18\
    \x04\x20\x03(\x0b2\x18.OakSave.VaultCardRewardR\x12unlockedRewardListB\0\
    \x12L\n\x14redeemed_reward_list\x18\x05\x20\x03(\x0b2\x18.OakSave.VaultC\
    ardRewardR\x12redeemedRewardListB\0\x12,\n\x11vault_card_chests\x18\x07\
    \x20\x01(\x05R\x0fvaultCardChestsB\0\x129\n\x18vault_card_chests_opened\
    \x18\x08\x20\x01(\rR\x15vaultCardChestsOpenedB\0\x123\n\x15vault_card_ke\
    ys_spent\x18\t\x20\x01(\rR\x12vaultCardKeysSpentB\0\x12A\n\x0cgear_rewar\
    ds\x18\n\x20\x03(\x0b2\x1c.OakSave.VaultCardGearRewardR\x0bgearRewardsB\
    \0:\0\"\x8e\x01\n\x1aVaultCardPreviousChallenge\x128\n\x17previous_chall\
    enge_seed\x18\x01\x20\x01(\x05R\x15previousChallengeSeedB\0\x124\n\x15pr\
    evious_challenge_id\x18\x02\x20\x01(\rR\x13previousChallengeIdB\0:\0B\0b\
    \x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
